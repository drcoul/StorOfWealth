'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _execa = require('execa');

var _execa2 = _interopRequireDefault(_execa);

var _merge = require('lodash/merge');

var _merge2 = _interopRequireDefault(_merge);

var _Task = require('./Task');

var _Task2 = _interopRequireDefault(_Task);

var _Tool = require('./Tool');

var _Tool2 = _interopRequireDefault(_Tool);

var _isObject = require('./helpers/isObject');

var _isObject2 = _interopRequireDefault(_isObject);

var _constants = require('./constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Routine extends _Task2.default {

  constructor(key, title, defaultConfig = {}) {
    super(title, null, defaultConfig);

    this.key = '';

    this.executeTask = (value, task) => this.wrap(task.run(value, this.context)).finally(() => {
      this.tool.render();
    });

    if (!key || typeof key !== 'string') {
      throw new Error('Routine key must be a valid unique string.');
    } else if (_constants.RESTRICTED_CONFIG_KEYS.includes(key)) {
      throw new Error(`Invalid routine key "${key}". This key is reserved.`);
    }

    this.key = key;

    this.action = this.execute.bind(this);

    this.status = _constants.PENDING;
  }

  bootstrap() {}

  configure(tool, parentConfig) {
    this.tool = tool;

    const config = parentConfig[this.key];

    if ((0, _isObject2.default)(config)) {
      (0, _merge2.default)(this.config, config);
    }

    this.bootstrap();

    return this;
  }

  execute(value) {
    return value;
  }

  executeCommand(command, args = [], options = {}) {
    return this.wrap(_execa2.default.stdout(command, args, options));
  }

  parallelizeSubroutines(value = null) {
    return _bluebird2.default.all(this.subroutines.map(routine => this.executeTask(value, routine)));
  }

  parallelizeTasks(value = null) {
    return _bluebird2.default.all(this.subtasks.map(task => this.executeTask(value, task)));
  }

  pipe(...routines) {
    routines.forEach(routine => {
      if (routine instanceof Routine) {
        this.subroutines.push(routine.configure(this.tool, this.config));
      } else {
        throw new Error('Routines must be an instance of `Routine`.');
      }
    });

    return this;
  }

  run(value, context = {}) {
    this.tool.startDebugGroup(this.key);

    return super.run(value, context).finally(() => {
      this.tool.stopDebugGroup();
      this.tool.render();
    });
  }

  serialize(initialValue, items, accumulator) {
    return items.reduce((promise, item) => promise.then(value => accumulator(value, item)), _bluebird2.default.resolve(initialValue));
  }

  serializeSubroutines(value = null) {
    return this.serialize(value, this.subroutines, this.executeTask);
  }

  serializeTasks(value = null) {
    return this.serialize(value, this.subtasks, this.executeTask);
  }

  task(title, action, config = {}) {
    if (typeof action !== 'function') {
      throw new Error('Tasks require an executable function.');
    }

    this.subtasks.push(new _Task2.default(title, action.bind(this), config));

    return this;
  }
}
exports.default = Routine; /**
                            * @copyright   2017, Miles Johnson
                            * @license     https://opensource.org/licenses/MIT
                            * 
                            */