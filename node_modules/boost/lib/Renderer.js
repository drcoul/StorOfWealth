'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _figures = require('figures');

var _figures2 = _interopRequireDefault(_figures);

var _Task = require('./Task');

var _Task2 = _interopRequireDefault(_Task);

var _constants = require('./constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @copyright   2017, Miles Johnson
 * @license     https://opensource.org/licenses/MIT
 * 
 */

class Renderer {
  indent(length) {
    return '    '.repeat(length);
  }

  render(tasks = []) {
    const output = [];

    tasks.forEach(task => {
      output.push(...this.renderTask(task, 0));
    });

    return output.join('\n');
  }

  renderTask(task, level = 0, suffix = '') {
    const output = [];

    let message = `${this.indent(level)}${this.renderStatus(task)} ${task.title}`;

    if (task.isSkipped()) {
      message += ` ${_chalk2.default.yellow('[skipped]')}`;
    } else if (task.hasFailed()) {
      message += ` ${_chalk2.default.red('[failed]')}`;
    } else if (suffix) {
      message += ` ${suffix}`;
    }

    output.push(message);

    if (task.subtasks.length) {
      let pendingTask;
      let runningTask;
      let failedTask;
      let passed = 0;

      task.subtasks.forEach(subTask => {
        if (subTask.isPending() && !pendingTask) {
          pendingTask = subTask;
        } else if (subTask.isRunning() && !runningTask) {
          runningTask = subTask;
        } else if (subTask.hasFailed() && !failedTask) {
          failedTask = subTask;
        } else if (subTask.hasPassed()) {
          passed += 1;
        }
      });

      const activeTask = failedTask || runningTask || pendingTask;
      const taskSuffix = _chalk2.default.gray(`[${passed}/${task.subtasks.length}]`);

      if (activeTask && (task.isRunning() || failedTask)) {
        output.push(...this.renderTask(activeTask, level + 1, taskSuffix));
      }
    }

    if (task.subroutines.length) {
      task.subroutines.forEach(routine => {
        output.push(...this.renderTask(routine, level + 1));
      });
    }

    return output;
  }

  renderStatus(task) {
    switch (task.status) {
      case _constants.PENDING:
        return _chalk2.default.gray(_figures2.default.bullet);
      case _constants.RUNNING:
        return _chalk2.default.gray(task.spinner());
      case _constants.SKIPPED:
        return _chalk2.default.yellow(_figures2.default.circleDotted);
      case _constants.PASSED:
        return _chalk2.default.green(_figures2.default.tick);
      case _constants.FAILED:
        return _chalk2.default.red(_figures2.default.cross);
      default:
        return '';
    }
  }
}
exports.default = Renderer;